import SoundManager from '../core/SoundManager.js';

export default class NeonConnect4 {
    constructor() {
        this.container = null;
        this.rows = 6;
        this.cols = 7;
        this.board = [];
        this.currentPlayer = 1; // 1 = Player, 2 = AI
        this.gameActive = false;
        this.aiThinking = false;
        this.aiTimeout = null;
        this.soundManager = SoundManager.getInstance();
    }

    async init(container) {
        this.container = container;
        this.render();
        this.startGame();
    }

    render() {
        this.container.innerHTML = `
            <div class="flex flex-col items-center justify-center h-full w-full select-none">
                <h2 class="text-4xl font-bold text-fuchsia-400 neon-text mb-2">NEON CONNECT 4</h2>
                <div id="nc4-status" class="text-xl text-white mb-4 h-8">Your Turn</div>

                <div class="relative bg-slate-800 p-4 rounded-xl border-4 border-slate-700 shadow-lg">
                    <div id="nc4-grid" class="grid grid-cols-7 gap-2 bg-slate-900 p-2 rounded-lg">
                        <!-- Cells generated by JS -->
                    </div>
                </div>

                <button class="back-btn mt-6 px-6 py-2 bg-slate-700 hover:bg-slate-600 text-white rounded transition-colors">
                    <i class="fas fa-arrow-left mr-2"></i> Back
                </button>
            </div>
            <style>
                .nc4-cell {
                    width: 40px;
                    height: 40px;
                    background-color: #1e293b; /* slate-800 */
                    border-radius: 50%;
                    transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
                    box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
                }
                .nc4-cell:hover {
                    border: 2px solid rgba(255,255,255,0.1);
                }
                .nc4-cell.p1 {
                    background-color: #e879f9; /* fuchsia-400 */
                    box-shadow: 0 0 15px #e879f9, inset 0 0 5px rgba(255,255,255,0.5);
                }
                .nc4-cell.p2 {
                    background-color: #22d3ee; /* cyan-400 */
                    box-shadow: 0 0 15px #22d3ee, inset 0 0 5px rgba(255,255,255,0.5);
                }
                .nc4-cell.win {
                    animation: pulse-win 1s infinite;
                    border: 3px solid #facc15; /* yellow */
                }
                @keyframes pulse-win {
                    0% { transform: scale(1); }
                    50% { transform: scale(1.1); }
                    100% { transform: scale(1); }
                }
                @media (min-height: 800px) {
                    .nc4-cell { width: 60px; height: 60px; }
                }
            </style>
        `;

        const grid = document.getElementById('nc4-grid');
        for (let r = 0; r < this.rows; r++) {
            for (let c = 0; c < this.cols; c++) {
                const cell = document.createElement('div');
                cell.className = 'nc4-cell cursor-pointer';
                cell.dataset.r = r;
                cell.dataset.c = c;
                cell.onclick = () => this.handleColumnClick(c);
                grid.appendChild(cell);
            }
        }

        this.container.querySelector('.back-btn').addEventListener('click', () => {
             if (window.miniGameHub) window.miniGameHub.goBack();
        });
    }

    startGame() {
        this.board = Array(this.rows).fill(null).map(() => Array(this.cols).fill(0));
        this.currentPlayer = 1;
        this.gameActive = true;
        this.aiThinking = false;
        this.updateBoardUI();
        this.updateStatus("Your Turn (Pink)");
    }

    updateStatus(msg) {
        const el = document.getElementById('nc4-status');
        if (el) el.textContent = msg;
    }

    handleColumnClick(col) {
        if (!this.gameActive || this.aiThinking) return;

        if (this.dropPiece(col, 1)) {
            // Valid move
            if (this.gameActive) {
                this.aiThinking = true;
                this.updateStatus("AI Thinking...");
                this.aiTimeout = setTimeout(() => this.aiMove(), 800);
            }
        } else {
            this.soundManager.playSound('error');
        }
    }

    dropPiece(col, player) {
        // Find lowest empty row in this col
        for (let r = this.rows - 1; r >= 0; r--) {
            if (this.board[r][col] === 0) {
                this.board[r][col] = player;
                this.animateDrop(r, col, player);

                if (this.checkWin(r, col, player)) {
                    this.gameActive = false;
                    const isPlayer = player === 1;
                    this.updateStatus(isPlayer ? "YOU WIN!" : "AI WINS!");
                    this.soundManager.playSound(isPlayer ? 'victory' : 'explosion');
                    setTimeout(() => this.showGameOver(isPlayer ? 100 : 0), 1500);
                } else if (this.checkDraw()) {
                    this.gameActive = false;
                    this.updateStatus("DRAW!");
                    this.soundManager.playTone(300, 'square', 0.2);
                    setTimeout(() => this.showGameOver(50), 1500);
                } else {
                    // Switch turn
                    this.currentPlayer = player === 1 ? 2 : 1;
                    if (this.currentPlayer === 1) this.updateStatus("Your Turn (Pink)");
                }
                return true;
            }
        }
        return false; // Column full
    }

    animateDrop(r, col, player) {
        const cells = document.querySelectorAll('.nc4-cell');
        const index = r * this.cols + col;
        const cell = cells[index];
        if (cell) {
             cell.classList.add(player === 1 ? 'p1' : 'p2');
             this.soundManager.playSound('click');
        }
    }

    updateBoardUI() {
        const cells = document.querySelectorAll('.nc4-cell');
        cells.forEach(c => {
            c.classList.remove('p1', 'p2', 'win');
        });
    }

    aiMove() {
        if (!this.gameActive) return;

        // Simple AI
        // 1. Check for winning move
        let move = this.findBestMove(2);
        // 2. Block player winning move
        if (move === -1) move = this.findBestMove(1);
        // 3. Random valid column, preferring center
        if (move === -1) {
            const validCols = [];
            for (let c = 0; c < this.cols; c++) {
                if (this.board[0][c] === 0) validCols.push(c);
            }

            // Prefer center columns: 3, 2/4, 1/5, 0/6
            const centerOrder = [3, 2, 4, 1, 5, 0, 6];
            for (let c of centerOrder) {
                if (validCols.includes(c) && Math.random() > 0.2) {
                    move = c;
                    break;
                }
            }
            // Fallback random
            if (move === -1 && validCols.length > 0) {
                move = validCols[Math.floor(Math.random() * validCols.length)];
            }
        }

        if (move !== -1) {
            this.dropPiece(move, 2);
        }
        this.aiThinking = false;
        this.aiTimeout = null;
    }

    findBestMove(player) {
        // Simulate dropping piece in each column
        for (let c = 0; c < this.cols; c++) {
            // Find row
            let r = -1;
            for (let i = this.rows - 1; i >= 0; i--) {
                if (this.board[i][c] === 0) {
                    r = i;
                    break;
                }
            }

            if (r !== -1) {
                // Simulate
                this.board[r][c] = player;
                const win = this.checkWin(r, c, player, true); // True = don't highlight
                this.board[r][c] = 0; // Undo
                if (win) return c;
            }
        }
        return -1;
    }

    checkWin(r, c, player, simulate = false) {
        // Check 4 directions
        const directions = [
            [[0, 1], [0, -1]], // Horizontal
            [[1, 0], [-1, 0]], // Vertical
            [[1, 1], [-1, -1]], // Diagonal \
            [[1, -1], [-1, 1]]  // Diagonal /
        ];

        for (const dir of directions) {
            let count = 1;
            let winningCells = [[r, c]];

            for (const delta of dir) {
                let currR = r + delta[0];
                let currC = c + delta[1];
                while (
                    currR >= 0 && currR < this.rows &&
                    currC >= 0 && currC < this.cols &&
                    this.board[currR][currC] === player
                ) {
                    count++;
                    winningCells.push([currR, currC]);
                    currR += delta[0];
                    currC += delta[1];
                }
            }

            if (count >= 4) {
                if (!simulate) this.highlightWin(winningCells);
                return true;
            }
        }
        return false;
    }

    highlightWin(cellsCoords) {
        const cells = document.querySelectorAll('.nc4-cell');
        cellsCoords.forEach(([r, c]) => {
            const idx = r * this.cols + c;
            if (cells[idx]) cells[idx].classList.add('win');
        });
    }

    checkDraw() {
        return this.board[0].every(cell => cell !== 0);
    }

    showGameOver(score) {
        if (window.miniGameHub) {
            window.miniGameHub.showGameOver(score, () => this.startGame());
        }
    }

    update(dt) {}
    draw() {}
    shutdown() {
        this.gameActive = false;
        if (this.aiTimeout) {
            clearTimeout(this.aiTimeout);
            this.aiTimeout = null;
        }
        this.container.innerHTML = '';
    }
}
