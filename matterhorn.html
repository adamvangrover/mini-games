<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matterhorn Ascent: Arcade Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050a10; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        /* Retro HUD */
        #hud-top {
            display: flex;
            justify-content: space-between;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 20px;
            border: 2px solid #555;
            color: #0f0;
            font-family: 'Courier New', Courier, monospace;
            font-weight: bold;
            font-size: 20px;
            text-shadow: 0 0 5px #0f0;
            backdrop-filter: blur(4px);
        }

        #hud-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.5);
            font-size: 24px;
        }

        #crosshair {
            width: 8px;
            height: 8px;
            background: rgba(255, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 4px #ff0000;
        }

        /* Stamina Bar */
        #stamina-container {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 20px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #555;
            border-radius: 10px;
            overflow: hidden;
        }
        #stamina-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff8800, #ffff00);
            transform-origin: left;
            transition: width 0.1s;
        }
        #stamina-label {
            text-align: center;
            color: white;
            font-family: monospace;
            font-size: 12px;
            margin-top: 5px;
            text-shadow: 1px 1px 0 #000;
        }

        /* Start Screen */
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, #1a2a6c, #b21f1f, #fdbb2d); /* Fallback */
            background-size: cover;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            z-index: 100;
            transition: opacity 1s;
        }
        
        #start-bg-image {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: url('https://upload.wikimedia.org/wikipedia/commons/thumb/6/60/Matterhorn_from_Domh%C3%BCtte_-_2.jpg/1200px-Matterhorn_from_Domh%C3%BCtte_-_2.jpg') no-repeat center center fixed;
            background-size: cover;
            opacity: 0.6;
            z-index: -1;
        }
        
        #start-overlay {
            background: rgba(0,0,0,0.85);
            padding: 40px;
            border-radius: 10px;
            text-align: center;
            border: 2px solid #fff;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            max-width: 600px;
        }

        h1 { font-size: 4em; margin: 0 0 10px 0; font-style: italic; text-shadow: 4px 4px 0 #000; letter-spacing: -2px; }
        .btn-group { display: flex; gap: 20px; justify-content: center; margin-top: 30px; pointer-events: auto; }
        
        button {
            background: #222;
            color: #ddd;
            border: 2px solid #555;
            padding: 15px 30px;
            font-size: 1.1em;
            cursor: pointer;
            transition: 0.2s;
            text-transform: uppercase;
            font-weight: bold;
            font-family: 'Courier New', monospace;
        }
        button:hover { background: #444; border-color: #fff; color: #fff; transform: translateY(-2px); box-shadow: 0 5px 15px rgba(0,0,0,0.5); }
        button.highlight { background: #8b0000; border-color: #ff3333; color: white; }
        button.highlight:hover { background: #cc0000; }

        /* Weather Overlay */
        #frost-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            box-shadow: inset 0 0 150px 80px rgba(255, 255, 255, 0.0);
            pointer-events: none;
            transition: box-shadow 2s;
            z-index: 5;
            mix-blend-mode: overlay;
        }
        
        #damage-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 50%, rgba(255,0,0,0.5) 100%);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            z-index: 6;
        }

        #message-area {
            position: absolute;
            bottom: 25%;
            width: 100%;
            text-align: center;
            color: #ffff00;
            font-size: 28px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
        }
        
        .controls-hint {
            position: absolute; 
            bottom: 20px; 
            left: 20px; 
            color: rgba(255,255,255,0.7); 
            font-family: monospace; 
            text-shadow: 1px 1px 0 #000;
            font-size: 14px;
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>
    <div id="frost-overlay"></div>
    <div id="damage-overlay"></div>

    <div id="ui-layer">
        <div id="hud-top">
            <div id="altitude">ALT: 1600m</div>
            <div id="condition">WEATHER: CLEAR</div>
        </div>
        
        <div id="crosshair"></div>
        
        <div id="message-area"></div>
        
        <div id="stamina-container">
            <div id="stamina-bar"></div>
            <div id="stamina-label">STAMINA</div>
        </div>
        
        <div class="controls-hint">
            [WASD] Move | [SPACE] Jump | [HOLD L-CLICK] Climb Walls | [SHIFT] Sprint
        </div>
    </div>

    <div id="start-screen">
        <div id="start-bg-image"></div>
        <div id="start-overlay">
            <h1>MATTERHORN '95</h1>
            <p style="font-size: 1.2em; color: #ccc;">ARCADE EDITION</p>
            <p style="font-size: 0.9em; color: #888; margin-bottom: 20px;">Use Headphones for Atmosphere</p>
            
            <div class="btn-group">
                <button onclick="startGame('solo')">Solo Expedition<br><span style="font-size:0.6em; color:#aaa;">Normal Difficulty</span></button>
                <button class="highlight" onclick="startGame('guide')">Hire Guide<br><span style="font-size:0.6em; color:#ffcccc;">Follow the Sherpa</span></button>
            </div>
            <p style="margin-top:20px; font-size: 0.9em; color: #888;">Click to Start & Lock Cursor.</p>
        </div>
    </div>

    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>

    <script>
        // --- Configuration ---
        const CFG = {
            baseHeight: 900,
            baseRadius: 450,
            snowLevel: 300,
            walkSpeed: 35,
            runSpeed: 60,
            climbSpeed: 25,
            gravity: 90,
            jumpForce: 35,
            guideSpeed: 16,
            staminaMax: 100,
            staminaDrainClimb: 25, // per second
            staminaDrainRun: 15,
            staminaRegen: 30
        };

        // --- Globals ---
        let scene, camera, renderer, clock;
        let mountain, guideMesh, axeMesh;
        let snowSystem;
        let raycasterForward, raycasterDown;
        
        // Audio Context
        let audioCtx, windNode, windGain, windFilter;
        let isAudioInit = false;
        
        // State
        let player = {
            velocity: new THREE.Vector3(),
            onGround: false,
            isClimbing: false,
            altitude: 1600,
            stamina: CFG.staminaMax,
            isDead: false
        };
        
        let inputs = { w: false, a: false, s: false, d: false, jump: false, sprint: false, click: false };
        let gameMode = 'solo';
        let isPlaying = false;
        let guidePathPoints = []; 
        let currentGuideIndex = 0;
        let hasFlag = false;

        const simplex = new SimplexNoise();

        // --- Init ---
        function init() {
            clock = new THREE.Clock();
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x6688cc);
            scene.fog = new THREE.FogExp2(0x6688cc, 0.0015);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 4000);
            camera.position.set(200, 50, 200);

            // Lighting
            const ambient = new THREE.HemisphereLight(0xffffff, 0x444455, 0.6);
            scene.add(ambient);

            const sun = new THREE.DirectionalLight(0xffffe0, 1.2);
            sun.position.set(200, 600, 300);
            sun.castShadow = true;
            sun.shadow.mapSize.width = 2048;
            sun.shadow.mapSize.height = 2048;
            sun.shadow.camera.near = 0.5;
            sun.shadow.camera.far = 1500;
            const d = 600;
            sun.shadow.camera.left = -d;
            sun.shadow.camera.right = d;
            sun.shadow.camera.top = d;
            sun.shadow.camera.bottom = -d;
            scene.add(sun);

            // Objects
            raycasterDown = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, -1, 0), 0, 20);
            raycasterForward = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, 0, -1), 0, 6);

            createMatterhorn();
            createPlayerTool();
            createSnow();

            // Events
            window.addEventListener('resize', onResize);
            setupInputs();
            
            animate();
        }

        // --- Audio Engine ---
        function initAudio() {
            if (isAudioInit) return;
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                audioCtx = new AudioContext();
                
                // Wind noise buffer
                const bufferSize = 2 * audioCtx.sampleRate;
                const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const output = noiseBuffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    const white = Math.random() * 2 - 1;
                    output[i] = (lastOut + (0.02 * white)) / 1.02;
                    lastOut = output[i];
                    output[i] *= 3.5; 
                }
                var lastOut = 0;

                windNode = audioCtx.createBufferSource();
                windNode.buffer = noiseBuffer;
                windNode.loop = true;
                
                windFilter = audioCtx.createBiquadFilter();
                windFilter.type = 'lowpass';
                windFilter.frequency.value = 400;

                windGain = audioCtx.createGain();
                windGain.gain.value = 0.1;

                windNode.connect(windFilter);
                windFilter.connect(windGain);
                windGain.connect(audioCtx.destination);
                
                windNode.start();
                isAudioInit = true;
            } catch(e) {
                console.warn("Audio init failed", e);
            }
        }

        function updateAudio(altitude, stormIntensity) {
            if(!isAudioInit) return;
            
            // Wind gets louder and higher pitched with altitude/storm
            const baseFreq = 400 + (altitude - 1600) * 0.5;
            const stormFreq = stormIntensity * 800;
            
            const targetFreq = Math.min(2000, baseFreq + stormFreq);
            const targetGain = 0.05 + (altitude/8000) + (stormIntensity * 0.3);

            windFilter.frequency.setTargetAtTime(targetFreq, audioCtx.currentTime, 0.5);
            windGain.gain.setTargetAtTime(targetGain, audioCtx.currentTime, 0.5);
        }

        // --- World Generation ---
        function createMatterhorn() {
            const height = CFG.baseHeight;
            const radius = CFG.baseRadius;
            const segments = 128;
            
            const geometry = new THREE.CylinderGeometry(0.1, radius, height, segments, 80, true);
            const pos = geometry.attributes.position;
            const colors = [];
            
            const v = new THREE.Vector3();
            
            for(let i=0; i<pos.count; i++){
                v.fromBufferAttribute(pos, i);
                
                const angle = Math.atan2(v.z, v.x);
                const yPct = (v.y + height/2) / height; 
                
                // Shaping Matterhorn
                const taper = Math.pow(yPct, 2.5) * 0.6; 
                const ridgeFactor = Math.abs(Math.cos(angle * 4)); 
                const faceDepth = 70 * (1-yPct); 
                
                const currentRadius = Math.sqrt(v.x*v.x + v.z*v.z);
                const newRadius = currentRadius - (faceDepth * (1 - ridgeFactor) * 0.9);
                
                v.x = Math.cos(angle) * newRadius;
                v.z = Math.sin(angle) * newRadius;

                // Noise
                const largeNoise = simplex.noise3D(v.x * 0.005, v.y * 0.005, v.z * 0.005) * 40;
                const detailNoise = simplex.noise3D(v.x * 0.03, v.y * 0.03, v.z * 0.03) * 8;
                
                // The HÃ¶rnli Ridge path
                const angleDeg = angle * (180/Math.PI);
                let isPath = false;
                // East ridge (around 0) is walkable
                if (Math.abs(angleDeg) < 12 || Math.abs(angleDeg - 90) < 4) {
                    v.y += (largeNoise * 0.2); 
                    isPath = true;
                } else {
                    v.x += largeNoise + detailNoise;
                    v.z += largeNoise + detailNoise;
                    v.y += largeNoise;
                }

                pos.setXYZ(i, v.x, v.y, v.z);

                // Colors
                const snowThresh = 0.35 - (largeNoise * 0.005);
                if (yPct > snowThresh || (isPath && yPct > 0.55)) {
                    // Snow
                    colors.push(0.9, 0.95, 1.0);
                } else if (isPath) {
                    // Path Rock
                    colors.push(0.4, 0.35, 0.3);
                } else {
                    // Dark Rock
                    const g = 0.15 + Math.random()*0.1;
                    colors.push(g, g, g+0.05);
                }
            }
            
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.computeVertexNormals();

            const mat = new THREE.MeshStandardMaterial({ 
                vertexColors: true, 
                roughness: 0.95,
                metalness: 0.1,
                flatShading: true 
            });
            mountain = new THREE.Mesh(geometry, mat);
            mountain.position.y = height/2 - 50;
            mountain.castShadow = true;
            mountain.receiveShadow = true;
            scene.add(mountain);

            // Ground
            const plane = new THREE.Mesh(
                new THREE.PlaneGeometry(3000, 3000),
                new THREE.MeshStandardMaterial({ color: 0x223322, roughness: 1 })
            );
            plane.rotation.x = -Math.PI/2;
            plane.position.y = -50;
            scene.add(plane);

            // Guide Path Calculation
            generateGuidePath(height);
        }

        function generateGuidePath(height) {
            let guideY = -40;
            let guideAngle = 0;
            let guideRad = CFG.baseRadius;
            
            while(guideY < height - 60) {
                guideY += 8;
                guideRad *= 0.945; 
                guideAngle += 0.03; 
                
                const gx = Math.cos(guideAngle) * guideRad;
                const gz = Math.sin(guideAngle) * guideRad;
                
                const rayOrigin = new THREE.Vector3(gx, 1000, gz);
                raycasterDown.set(rayOrigin, new THREE.Vector3(0,-1,0));
                const hits = raycasterDown.intersectObject(mountain);
                
                if(hits.length > 0) {
                    guidePathPoints.push(hits[0].point.clone().add(new THREE.Vector3(0, 1.5, 0)));
                } else {
                    guidePathPoints.push(new THREE.Vector3(gx, guideY, gz));
                }
            }
            guidePathPoints.push(new THREE.Vector3(0, height - 50, 0));
        }

        function createPlayerTool() {
            const axeGroup = new THREE.Group();
            
            // Handle
            const handleGeo = new THREE.CylinderGeometry(0.04, 0.05, 1.4, 8);
            const handleMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const handle = new THREE.Mesh(handleGeo, handleMat);
            handle.position.y = -0.5;
            axeGroup.add(handle);

            // Head
            const headGeo = new THREE.BoxGeometry(0.5, 0.08, 0.08);
            const headMat = new THREE.MeshStandardMaterial({ color: 0xAAAAAA, metalness: 0.8, roughness: 0.3 });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 0.2;
            head.position.x = 0.15;
            axeGroup.add(head);

            // Pick
            const pickGeo = new THREE.ConeGeometry(0.04, 0.4, 8);
            const pick = new THREE.Mesh(pickGeo, headMat);
            pick.rotation.z = -Math.PI/2;
            pick.position.set(-0.25, 0.2, 0);
            axeGroup.add(pick);

            axeGroup.position.set(0.6, -0.6, -1.2);
            axeGroup.rotation.x = Math.PI/10;
            axeGroup.rotation.y = -Math.PI/10;
            
            camera.add(axeGroup);
            scene.add(camera);
            axeMesh = axeGroup;
        }

        function createSnow() {
            const particleCount = 3000;
            const geom = new THREE.BufferGeometry();
            const pos = [];
            for(let i=0; i<particleCount; i++){
                pos.push(
                    (Math.random()-0.5)*500,
                    (Math.random())*900,
                    (Math.random()-0.5)*500
                );
            }
            geom.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.6,
                transparent: true,
                opacity: 0.7
            });
            snowSystem = new THREE.Points(geom, mat);
            scene.add(snowSystem);
        }

        function spawnGuide() {
            const geo = new THREE.CapsuleGeometry(1, 3.5, 4, 8);
            const mat = new THREE.MeshLambertMaterial({ color: 0xff4400 }); 
            guideMesh = new THREE.Mesh(geo, mat);
            guideMesh.position.copy(guidePathPoints[0]);
            guideMesh.castShadow = true;
            scene.add(guideMesh);
            
            const pack = new THREE.Mesh(new THREE.BoxGeometry(1.6,2,1.2), new THREE.MeshStandardMaterial({color:0x3333aa}));
            pack.position.set(0, 0.5, -0.8);
            guideMesh.add(pack);
        }

        function createFlag(pos) {
            const pole = new THREE.Mesh(
                new THREE.CylinderGeometry(0.05, 0.05, 5),
                new THREE.MeshStandardMaterial({color: 0x222222})
            );
            const cloth = new THREE.Mesh(
                new THREE.BoxGeometry(2.5, 1.5, 0.05),
                new THREE.MeshStandardMaterial({color: 0xff0000})
            );
            cloth.position.set(1.25, 1.5, 0);
            
            const group = new THREE.Group();
            group.add(pole);
            group.add(cloth);
            group.position.copy(pos);
            scene.add(group);
            hasFlag = true;
        }

        // --- Input ---
        function setupInputs() {
            const onKey = (e, v) => {
                const k = e.code;
                if(k === 'KeyW') inputs.w = v;
                if(k === 'KeyS') inputs.s = v;
                if(k === 'KeyA') inputs.a = v;
                if(k === 'KeyD') inputs.d = v;
                if(k === 'Space') inputs.jump = v;
                if(k === 'ShiftLeft') inputs.sprint = v;
                if(k === 'KeyF' && v && player.altitude > 4300 && !hasFlag) {
                    createFlag(camera.position);
                    showMessage("FLAG PLANTED! YOU CONQUERED THE MATTERHORN!", 8000);
                    setTimeout(() => document.getElementById('start-overlay').style.display='block', 4000);
                }
            };
            document.addEventListener('keydown', e => onKey(e, true));
            document.addEventListener('keyup', e => onKey(e, false));
            
            document.addEventListener('mousedown', () => {
                if(!isPlaying) return;
                inputs.click = true;
                if(!document.pointerLockElement) document.body.requestPointerLock();
                
                // Swing Axe
                if(axeMesh) {
                    axeMesh.rotation.x = Math.PI/1.5; 
                    setTimeout(()=> axeMesh.rotation.x = Math.PI/10, 150);
                }
            });
            document.addEventListener('mouseup', () => inputs.click = false);
            
            document.addEventListener('mousemove', e => {
                if(document.pointerLockElement && !player.isDead) {
                    camera.rotation.y -= e.movementX * 0.002;
                    camera.rotation.x -= e.movementY * 0.002;
                    camera.rotation.x = Math.max(-1.5, Math.min(1.5, camera.rotation.x));
                }
            });
        }

        // --- Game Logic ---
        function startGame(mode) {
            gameMode = mode;
            document.getElementById('start-screen').style.opacity = '0';
            setTimeout(()=> document.getElementById('start-screen').style.display = 'none', 1000);
            isPlaying = true;
            initAudio();

            player.stamina = CFG.staminaMax;
            player.isDead = false;
            
            // Spawn point
            const startNode = guidePathPoints[0] || new THREE.Vector3(100,0,100);
            camera.position.set(startNode.x + 10, startNode.y + 10, startNode.z + 10);
            camera.lookAt(0, 400, 0);

            if(mode === 'guide') {
                if(guideMesh) scene.remove(guideMesh);
                spawnGuide();
                showMessage("FOLLOW THE GUIDE. STAY CLOSE.", 4000);
            } else {
                if(guideMesh) scene.remove(guideMesh);
                showMessage("SOLO ASCENT. WATCH YOUR STAMINA.", 4000);
            }
        }

        function showMessage(msg, duration=3000) {
            const el = document.getElementById('message-area');
            el.innerText = msg;
            el.style.opacity = 1;
            setTimeout(() => el.style.opacity = 0, duration);
        }

        function updateStamina(dt) {
            let drain = 0;
            if(player.isClimbing) {
                drain = CFG.staminaDrainClimb;
                // Don't drain if not moving vertically? No, holding on is hard.
                if(!inputs.w && !inputs.s) drain *= 0.2; 
            } else if (inputs.sprint && (inputs.w || inputs.a || inputs.s || inputs.d)) {
                drain = CFG.staminaDrainRun;
            }

            if(drain > 0) {
                player.stamina -= drain * dt;
                if(player.stamina <= 0) {
                    player.stamina = 0;
                    if(player.isClimbing) {
                        player.isClimbing = false; // Fall
                        showMessage("GRIP LOST!", 1000);
                    }
                    inputs.sprint = false;
                }
            } else {
                // Regen
                if(player.onGround) player.stamina += CFG.staminaRegen * dt;
                if(player.stamina > CFG.staminaMax) player.stamina = CFG.staminaMax;
            }

            // UI
            const bar = document.getElementById('stamina-bar');
            bar.style.width = player.stamina + '%';
            if(player.stamina < 30) bar.style.background = '#ff0000';
            else bar.style.background = 'linear-gradient(90deg, #ff8800, #ffff00)';
        }

        function animate() {
            requestAnimationFrame(animate);
            if(!isPlaying || player.isDead) {
                renderer.render(scene, camera);
                return;
            }

            const dt = Math.min(clock.getDelta(), 0.1);
            
            // Camera Orientation Vectors
            const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
            fwd.y = 0; fwd.normalize();
            const right = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion);
            right.y = 0; right.normalize();

            // Movement Calculation
            const moveVec = new THREE.Vector3();
            if(inputs.w) moveVec.add(fwd);
            if(inputs.s) moveVec.sub(fwd);
            if(inputs.d) moveVec.add(right);
            if(inputs.a) moveVec.sub(right);
            moveVec.normalize();

            let speed = inputs.sprint ? CFG.runSpeed : CFG.walkSpeed;
            if(player.isClimbing) speed = CFG.climbSpeed;
            
            // Raycast Walls
            raycasterForward.set(camera.position, camera.getWorldDirection(new THREE.Vector3()));
            const wallHits = raycasterForward.intersectObject(mountain);
            const nearWall = wallHits.length > 0 && wallHits[0].distance < 5;

            // Climbing State
            if(nearWall && inputs.click && player.stamina > 0) {
                player.isClimbing = true;
                player.velocity.y = 0;
                
                if(inputs.w) camera.position.y += speed * dt;
                if(inputs.s) camera.position.y -= speed * dt;
                
                // Wall strafe
                if(inputs.a || inputs.d) {
                      camera.position.addScaledVector(right, (inputs.d ? 1 : -1) * speed * dt * 0.5);
                }
                
                // Axe visual
                axeMesh.position.z = -0.6;
                axeMesh.position.y = -0.4;
            } else {
                player.isClimbing = false;
                axeMesh.position.z = -1.2;
                
                camera.position.addScaledVector(moveVec, speed * dt);

                if(!player.onGround) {
                    player.velocity.y -= CFG.gravity * dt;
                } else {
                    player.velocity.y = 0;
                    if(inputs.jump && player.stamina > 10) {
                        player.velocity.y = CFG.jumpForce;
                        player.onGround = false;
                        player.stamina -= 10;
                    }
                }
                camera.position.y += player.velocity.y * dt;
            }

            // Ground Collision / Falling
            raycasterDown.set(camera.position, new THREE.Vector3(0,-1,0));
            const groundHits = raycasterDown.intersectObject(mountain);
            const heightBuffer = 5; 
            
            if(groundHits.length > 0) {
                const dist = groundHits[0].distance;
                if(dist < heightBuffer && player.velocity.y <= 0) {
                    // Impact
                    if(player.velocity.y < -60) {
                        // Hard fall
                        document.getElementById('damage-overlay').style.opacity = 1;
                        setTimeout(()=>document.getElementById('damage-overlay').style.opacity = 0, 300);
                        player.stamina -= 30;
                    }
                    camera.position.y = groundHits[0].point.y + heightBuffer;
                    player.onGround = true;
                } else {
                    player.onGround = false;
                }
            } else {
                player.onGround = false;
            }

            // Stamina
            updateStamina(dt);

            // Void Death
            if(camera.position.y < -100) {
                camera.position.set(200, 50, 200);
                player.velocity.set(0,0,0);
                showMessage("YOU FELL INTO THE ABYSS. RESPAWNING.");
                player.stamina = CFG.staminaMax;
            }

            // Guide NPC
            if(gameMode === 'guide' && guideMesh) {
                const target = guidePathPoints[currentGuideIndex];
                if(target) {
                    const dir = new THREE.Vector3().subVectors(target, guideMesh.position);
                    const dist = dir.length();
                    
                    if(dist < 1.5) {
                        currentGuideIndex++;
                    } else {
                        dir.normalize();
                        guideMesh.position.addScaledVector(dir, CFG.guideSpeed * dt);
                        guideMesh.lookAt(target);
                    }
                }
            }

            // Environment & Audio
            const alt = Math.floor(1600 + (camera.position.y * 3));
            document.getElementById('altitude').innerText = `ALT: ${alt}m`;
            
            const weatherIntensity = Math.max(0, (alt - 2200) / 2000);
            document.getElementById('frost-overlay').style.boxShadow = `inset 0 0 150px ${weatherIntensity*150}px rgba(255, 255, 255, ${weatherIntensity*0.5})`;
            
            if(weatherIntensity > 0.8) document.getElementById('condition').innerText = "COND: BLIZZARD";
            else if(weatherIntensity > 0.4) document.getElementById('condition').innerText = "COND: HIGH WIND";
            else document.getElementById('condition').innerText = "COND: CLEAR";

            updateAudio(alt, weatherIntensity);

            // Snow Animation
            const positions = snowSystem.geometry.attributes.position.array;
            for(let i=0; i<positions.length; i+=3) {
                positions[i+1] -= (25 + (weatherIntensity * 60)) * dt; 
                positions[i] += Math.sin(clock.elapsedTime + positions[i+1]*0.01) * (0.5 + weatherIntensity);
                positions[i+2] += Math.cos(clock.elapsedTime + positions[i+1]*0.01) * (0.5 + weatherIntensity);
                
                if(positions[i+1] < camera.position.y - 100) {
                    positions[i+1] = camera.position.y + 150;
                    positions[i] = camera.position.x + (Math.random()-0.5)*250;
                    positions[i+2] = camera.position.z + (Math.random()-0.5)*250;
                }
            }
            snowSystem.geometry.attributes.position.needsUpdate = true;

            // Axe Bob / Sway
            if((moveVec.length() > 0 || player.isClimbing) && axeMesh) {
                const bob = Math.sin(clock.elapsedTime * 12) * 0.03;
                axeMesh.position.y += bob * 0.1;
                axeMesh.rotation.z = bob * 0.5;
            }

            renderer.render(scene, camera);
        }
        
        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();

    </script>
</body>
</html>
