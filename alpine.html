<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Matterhorn: Alpine Legend</title>
    <style>
        :root { --glass: rgba(15, 23, 42, 0.6); --acc: #38bdf8; --font: 'Segoe UI', sans-serif; }
        body { margin: 0; overflow: hidden; background: #000; font-family: var(--font); color: white; user-select: none; }
        canvas { display: block; width: 100%; height: 100%; outline: none; }
        
        /* UI OVERLAYS */
        #ui-layer { position: absolute; inset: 0; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; padding: 20px; }
        .interactive { pointer-events: auto; }
        .hidden { opacity: 0 !important; pointer-events: none !important; }

        /* HUD */
        .hud-panel { background: var(--glass); padding: 15px; border-radius: 12px; backdrop-filter: blur(8px); border: 1px solid rgba(255,255,255,0.1); pointer-events: none; transition: opacity 0.3s; }
        .stat-row { display: flex; align-items: center; gap: 10px; margin-bottom: 6px; font-size: 14px; font-weight: 600; text-shadow: 0 1px 2px black; }
        .bar-track { width: 120px; height: 6px; background: rgba(0,0,0,0.5); border-radius: 3px; overflow: hidden; }
        .bar-fill { height: 100%; transition: width 0.3s ease-out; }

        /* NOTIFICATIONS */
        #notifs { position: absolute; top: 80px; right: 20px; display: flex; flex-direction: column; align-items: flex-end; gap: 10px; }
        .notif { background: rgba(0,0,0,0.8); padding: 10px 20px; border-radius: 8px; border-right: 4px solid var(--acc); animation: slideIn 0.3s ease-out; font-size: 14px; }
        @keyframes slideIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }

        /* PROMPT */
        #prompt { position: absolute; bottom: 20%; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); padding: 8px 20px; border-radius: 20px; font-weight: bold; letter-spacing: 1px; transition: opacity 0.2s; }

        /* MINIGAME OVERLAY */
        #minigame-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.85); z-index: 100; display: flex; flex-direction: column; align-items: center; justify-content: center; opacity: 0; pointer-events: none; transition: opacity 0.3s; }
        #minigame-overlay.active { opacity: 1; pointer-events: auto; }
        #mg-canvas { border: 2px solid #555; background: #222; margin: 20px; border-radius: 8px; }
        
        /* START SCREEN */
        #start-screen { position: fixed; inset: 0; background: linear-gradient(rgba(0,0,0,0.3), rgba(0,0,0,0.6)), url('https://images.unsplash.com/photo-1518098268026-4e187743363b?auto=format&fit=crop&w=1920&q=80') center/cover; z-index: 200; display: flex; align-items: center; justify-content: center; flex-direction: column; text-align: center; }
        h1 { font-size: 5rem; font-weight: 100; letter-spacing: 10px; margin: 0; text-shadow: 0 4px 20px rgba(0,0,0,0.5); }
        h2 { font-weight: 300; color: #cbd5e1; letter-spacing: 4px; text-transform: uppercase; font-size: 1.2rem; margin-top: 10px; }
        button { background: white; color: black; border: none; padding: 15px 40px; font-size: 1.2rem; font-weight: bold; letter-spacing: 2px; cursor: pointer; margin-top: 40px; transition: transform 0.1s; border-radius: 4px; }
        button:hover { transform: scale(1.05); }

        /* CONTROLS GUIDE */
        .controls { position: absolute; bottom: 20px; left: 20px; color: rgba(255,255,255,0.5); font-size: 0.8rem; }
    </style>
    <!-- Dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
</head>
<body>

    <canvas id="game-canvas"></canvas>

    <div id="ui-layer">
        <div class="hud-panel" id="hud">
            <div class="stat-row"><span>üèîÔ∏è ALT</span><span id="ui-alt" style="margin-left:auto">0m</span></div>
            <div class="stat-row"><span>üå°Ô∏è TEMP</span><div class="bar-track" style="margin-left:auto"><div id="ui-temp" class="bar-fill" style="background:#ef4444; width:100%"></div></div></div>
            <div class="stat-row"><span>‚ö° ENGY</span><div class="bar-track" style="margin-left:auto"><div id="ui-stam" class="bar-fill" style="background:#fbbf24; width:100%"></div></div></div>
            <div class="stat-row" style="margin-top:10px; color:#fbbf24"><span>‚Ç£ FUNDS</span><span id="ui-money" style="margin-left:auto">0</span></div>
        </div>

        <div id="notifs"></div>
        <div id="prompt" class="hidden">PRESS [E]</div>
        <div class="controls">WASD: Move | SHIFT: Run | MOUSE: Look | E: Interact</div>
    </div>

    <div id="minigame-overlay">
        <h2 id="mg-title">Minigame</h2>
        <canvas id="mg-canvas" width="600" height="400"></canvas>
        <p id="mg-desc">Instructions</p>
        <button onclick="Game.exitMinigame()">EXIT</button>
    </div>

    <div id="start-screen">
        <h1>MATTERHORN</h1>
        <h2>Alpine Legend</h2>
        <button onclick="Game.start()">BEGIN ASCENT</button>
    </div>

<script>
/** * UTILS 
 * Procedural generation for photorealistic textures
 */
const Utils = {
    rand: (min, max) => Math.random() * (max - min) + min,
    
    // Generates a high-quality noise texture for terrain
    createTerrainTexture: (width, height) => {
        const canvas = document.createElement('canvas');
        canvas.width = width; canvas.height = height;
        const ctx = canvas.getContext('2d');
        const imgData = ctx.createImageData(width, height);
        const noise = new SimplexNoise();
        
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const nx = x/width - 0.5, ny = y/height - 0.5;
                // Layered noise for detail
                let e = 1 * noise.noise2D(3 * nx, 3 * ny) 
                      + 0.5 * noise.noise2D(10 * nx, 10 * ny) 
                      + 0.25 * noise.noise2D(20 * nx, 20 * ny);
                e = (e + 1) / 2; // Normalize 0-1
                
                const i = (x + y * width) * 4;
                // Colors based on noise value (Snow vs Rock)
                let r, g, b;
                if(e > 0.6) { // Snow
                    r=255; g=255; b=255; 
                } else if (e > 0.4) { // Transition
                    r=180; g=180; b=180;
                } else { // Dark Rock
                    r=60 + e*40; g=55 + e*40; b=50 + e*40;
                }
                
                // Add some noise grain
                const grain = (Math.random()-0.5)*20;
                
                imgData.data[i] = r + grain;
                imgData.data[i+1] = g + grain;
                imgData.data[i+2] = b + grain;
                imgData.data[i+3] = 255;
            }
        }
        ctx.putImageData(imgData, 0, 0);
        const tex = new THREE.CanvasTexture(canvas);
        tex.wrapS = THREE.RepeatWrapping;
        tex.wrapT = THREE.RepeatWrapping;
        tex.repeat.set(4, 4);
        return tex;
    },

    // Generates a normal map from height data for realistic lighting
    createNormalMap: (width, height) => {
        // Simplified procedural normal map generation would go here
        // Returning null to use flat shading for performance/simplicity in this demo
        // but high-poly geometry will handle most shadows.
        return null; 
    }
};

/**
 * STATE
 * Central Data Store
 */
const State = {
    money: 100,
    stats: { temp: 100, stamina: 100, maxStamina: 100 },
    inventory: [],
    time: 12, // Hours
    activeGame: null
};

/**
 * INPUT SYSTEM
 */
class Input {
    constructor() {
        this.keys = {};
        this.yaw = 0;
        this.pitch = 0;
        this.mouseDown = false;
        
        window.addEventListener('keydown', e => this.keys[e.code] = true);
        window.addEventListener('keyup', e => {
            this.keys[e.code] = false;
            if(e.code === 'KeyE') Game.interact();
        });
        
        window.addEventListener('mousedown', () => {
            document.body.requestPointerLock();
            this.mouseDown = true;
        });
        window.addEventListener('mouseup', () => this.mouseDown = false);
        
        window.addEventListener('mousemove', e => {
            if(document.pointerLockElement === document.body) {
                this.yaw -= e.movementX * 0.002;
                this.pitch -= e.movementY * 0.002;
                this.pitch = Math.max(-1.5, Math.min(1.5, this.pitch));
            }
        });
    }
}

/**
 * WORLD
 * Terrain, Water, Sky, Environment
 */
class World {
    constructor(scene) {
        this.scene = scene;
        this.simplex = new SimplexNoise();
        this.interactables = [];
        this.initMaterials();
        this.generateTerrain();
        this.generateWater();
        this.generateDetails();
    }

    initMaterials() {
        // High quality PBR materials
        const tex = Utils.createTerrainTexture(1024, 1024);
        this.matTerrain = new THREE.MeshStandardMaterial({
            map: tex,
            roughness: 0.9,
            metalness: 0.1,
            flatShading: true // Low poly style but high res texture
        });
        
        this.matWater = new THREE.MeshPhysicalMaterial({
            color: 0x22aadd,
            transmission: 0.6,
            opacity: 0.8,
            metalness: 0.2,
            roughness: 0.1,
            ior: 1.33,
            transparent: true
        });
    }

    getHeight(x, z) {
        // The Matterhorn Formula
        const dist = Math.sqrt(x*x + z*z);
        let y = 0;
        
        // Base rolling hills
        y += this.simplex.noise2D(x*0.003, z*0.003) * 60;
        
        // The Peak (Exponential rise)
        const mountainBase = 800;
        if(dist < mountainBase) {
            const factor = (mountainBase - dist) / mountainBase;
            y += Math.pow(factor, 3) * 800; // Sharp peak
            
            // Ridges
            const angle = Math.atan2(z, x);
            const ridges = Math.cos(angle * 3); // 3 faces of Matterhorn
            y += ridges * factor * 100;
        }

        // Noise detail
        y += this.simplex.noise2D(x*0.02, z*0.02) * 10;
        
        // Lake depression
        if(x > 100 && x < 400 && z > 100 && z < 400) {
            y -= 40;
        }

        return Math.max(-50, y);
    }

    generateTerrain() {
        const geo = new THREE.PlaneGeometry(2000, 2000, 256, 256);
        geo.rotateX(-Math.PI/2);
        
        const pos = geo.attributes.position;
        for(let i=0; i<pos.count; i++) {
            const x = pos.getX(i);
            const z = pos.getZ(i);
            pos.setY(i, this.getHeight(x, z));
        }
        geo.computeVertexNormals();
        
        this.mesh = new THREE.Mesh(geo, this.matTerrain);
        this.mesh.receiveShadow = true;
        this.mesh.castShadow = true;
        this.scene.add(this.mesh);
    }

    generateWater() {
        const geo = new THREE.PlaneGeometry(300, 300);
        geo.rotateX(-Math.PI/2);
        this.water = new THREE.Mesh(geo, this.matWater);
        this.water.position.set(250, -25, 250); // In the depression
        this.scene.add(this.water);
    }

    generateDetails() {
        // Procedural Trees
        const treeGeo = new THREE.ConeGeometry(4, 12, 6);
        const treeMat = new THREE.MeshStandardMaterial({ color: 0x1a472a, roughness: 0.8 });
        
        for(let i=0; i<300; i++) {
            const x = Utils.rand(-800, 800);
            const z = Utils.rand(-800, 800);
            const y = this.getHeight(x, z);
            
            // Only below snow line and above water
            if(y > -20 && y < 200) {
                const tree = new THREE.Mesh(treeGeo, treeMat);
                tree.position.set(x, y+6, z);
                tree.castShadow = true;
                tree.scale.setScalar(Utils.rand(0.8, 1.5));
                this.scene.add(tree);
            }
        }

        // Village Buildings
        this.addBuilding(0, 50, 0x8B4513, "Chocolate Shop", "chocolate");
        this.addBuilding(40, 60, 0xA0522D, "Fondue Chalet", "fondue");
        this.addBuilding(-40, 70, 0x555555, "Gear Station", "gear");
    }

    addBuilding(x, z, color, name, type) {
        const y = this.getHeight(x, z);
        const group = new THREE.Group();
        
        const base = new THREE.Mesh(new THREE.BoxGeometry(10, 8, 10), new THREE.MeshStandardMaterial({color}));
        const roof = new THREE.Mesh(new THREE.ConeGeometry(9, 6, 4), new THREE.MeshStandardMaterial({color: 0x222222}));
        roof.position.y = 7;
        roof.rotation.y = Math.PI/4;
        
        group.add(base, roof);
        group.position.set(x, y+4, z);
        group.castShadow = true;
        this.scene.add(group);

        this.interactables.push({ pos: new THREE.Vector3(x,y,z), radius: 15, name, type });
    }
}

/**
 * GAME ENGINE
 */
const Game = {
    init() {
        this.canvas = document.getElementById('game-canvas');
        
        // Renderer
        this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true, alpha: false });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        this.renderer.toneMapping = THREE.ACESFilmicToneMapping; // Photorealism key
        this.renderer.outputEncoding = THREE.sRGBEncoding;

        // Scene
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x87ceeb);
        this.scene.fog = new THREE.FogExp2(0x87ceeb, 0.0015); // Alpine haze

        // Camera
        this.camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 5000);

        // Lighting
        const ambi = new THREE.HemisphereLight(0xffffff, 0x080820, 0.5);
        this.scene.add(ambi);

        this.sun = new THREE.DirectionalLight(0xfffdb0, 1.5);
        this.sun.position.set(200, 500, 200);
        this.sun.castShadow = true;
        this.sun.shadow.mapSize.width = 2048;
        this.sun.shadow.mapSize.height = 2048;
        this.sun.shadow.bias = -0.0001;
        this.sun.shadow.camera.far = 2000;
        this.sun.shadow.camera.left = -500; this.sun.shadow.camera.right = 500;
        this.sun.shadow.camera.top = 500; this.sun.shadow.camera.bottom = -500;
        this.scene.add(this.sun);

        // Systems
        this.input = new Input();
        this.world = new World(this.scene);
        this.player = { pos: new THREE.Vector3(0, 100, 100), vel: new THREE.Vector3() };
        
        // Loop
        this.clock = new THREE.Clock();
        this.loop = this.loop.bind(this);
        requestAnimationFrame(this.loop);

        window.addEventListener('resize', () => {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
        });
    },

    start() {
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('hud').style.opacity = 1;
        // Teleport to spawn
        const h = this.world.getHeight(0, 20) + 5;
        this.player.pos.set(0, h, 20);
    },

    loop() {
        requestAnimationFrame(this.loop);
        const dt = Math.min(this.clock.getDelta(), 0.1);

        if(!State.activeGame) {
            this.updatePlayer(dt);
            this.updateCamera();
        }

        this.renderer.render(this.scene, this.camera);
    },

    updatePlayer(dt) {
        const speed = this.input.keys['ShiftLeft'] ? 15 : 8;
        const dir = new THREE.Vector3();
        
        // Camera Direction
        const camDir = new THREE.Vector3(Math.sin(this.input.yaw), 0, Math.cos(this.input.yaw));
        const camRight = new THREE.Vector3(Math.sin(this.input.yaw + Math.PI/2), 0, Math.cos(this.input.yaw + Math.PI/2));

        if(this.input.keys['KeyW']) dir.add(camDir);
        if(this.input.keys['KeyS']) dir.sub(camDir);
        if(this.input.keys['KeyA']) dir.add(camRight);
        if(this.input.keys['KeyD']) dir.sub(camRight);

        if(dir.lengthSq() > 0) dir.normalize();

        // Physics
        this.player.pos.addScaledVector(dir, speed * dt);
        
        // Gravity / Terrain Snap
        const groundH = this.world.getHeight(this.player.pos.x, this.player.pos.z);
        this.player.pos.y = groundH + 2; // Simple snap

        // Interactions
        const active = this.world.interactables.find(i => i.pos.distanceTo(this.player.pos) < i.radius);
        const prompt = document.getElementById('prompt');
        if(active) {
            prompt.classList.remove('hidden');
            prompt.innerText = `[E] ${active.name}`;
            this.activeInteractable = active;
        } else {
            prompt.classList.add('hidden');
            this.activeInteractable = null;
        }

        // Stats
        if(this.player.pos.y > 300) State.stats.temp -= dt * 2; // Cold
        else State.stats.temp += dt * 5; // Warm
        State.stats.temp = Utils.rand(0, 100) > 102 ? 0 : Math.max(0, Math.min(100, State.stats.temp));
        
        this.updateHUD();
    },

    updateCamera() {
        const target = this.player.pos.clone().add(new THREE.Vector3(0, 2, 0)); // Head
        const offset = new THREE.Vector3(0, 5, -10); // Behind
        offset.applyAxisAngle(new THREE.Vector3(1,0,0), -this.input.pitch);
        offset.applyAxisAngle(new THREE.Vector3(0,1,0), this.input.yaw);
        
        const camPos = target.clone().add(offset);
        this.camera.position.lerp(camPos, 0.1);
        this.camera.lookAt(target);
    },

    interact() {
        if(this.activeInteractable) {
            if(this.activeInteractable.type === 'chocolate') this.startMinigame('chocolate');
            if(this.activeInteractable.type === 'fondue') this.startMinigame('fondue');
        }
    },

    updateHUD() {
        document.getElementById('ui-alt').innerText = Math.round(this.player.pos.y) + 'm';
        document.getElementById('ui-money').innerText = State.money;
        document.getElementById('ui-temp').style.width = State.stats.temp + '%';
        // Warning color
        document.getElementById('ui-temp').style.backgroundColor = State.stats.temp < 30 ? '#38bdf8' : '#ef4444';
    },

    // --- MINIGAMES ---
    startMinigame(type) {
        State.activeGame = type;
        document.getElementById('minigame-overlay').classList.add('active');
        document.exitPointerLock();
        
        const canvas = document.getElementById('mg-canvas');
        const ctx = canvas.getContext('2d');
        const title = document.getElementById('mg-title');
        
        this.mgLoop = setInterval(() => {
            ctx.fillStyle = '#222';
            ctx.fillRect(0,0,600,400);
            
            if(type === 'chocolate') {
                title.innerText = "Chocolate Mixer";
                // Simple bar game
                const t = Date.now() / 500;
                const x = 300 + Math.sin(t) * 250;
                ctx.fillStyle = 'green'; ctx.fillRect(280, 50, 40, 300); // Target
                ctx.fillStyle = 'white'; ctx.fillRect(x, 50, 10, 300); // Cursor
                
                // Logic handled in exit for simplicity in this demo
            }
        }, 16);
    },

    exitMinigame() {
        clearInterval(this.mgLoop);
        State.activeGame = null;
        document.getElementById('minigame-overlay').classList.remove('active');
        document.body.requestPointerLock();
        this.notify("Task Complete! +50 ‚Ç£");
        State.money += 50;
    },

    notify(msg) {
        const n = document.createElement('div');
        n.className = 'notif'; n.innerText = msg;
        document.getElementById('notifs').appendChild(n);
        setTimeout(() => n.remove(), 3000);
    }
};

window.onload = () => Game.init();

</script>
</body>
</html>
